1. в лдаваскрипте все переменные можно условно разделить на два типа:
    - локальные - переменные определенные внутри какой-то фунцкции или блока кода - тоесть доступные только внутри функции или блока кода
    - глобальные - переменные которые не находятся внутри функции или блока кода - тоесть доступные везде.

2/3  все шлобальные переменные(созданые с помоштю var или FD) являются свойствами или методами глобального обьекта или подругому это(object environment record), в браузере таким шлобальным обектом является window.
 поэтому когда мы пишем highFive или myBestFunc, это все равно что написать window.highFive = 5;.

4. но оьращаю ваше внимание что так работает только при инициализации переменной с помощтю кейворда var. при использовании let или const
создается блочная переменная которая не является свойством глобального обекта, но является частью declarative environment.

5. давайте еще раз вспомним как работает хоистинг. хоистинг возможет потому что скрипт исполняется в две фазы.
    1. чтение скрипта - инициальзиция переменных.
    2. исполнение скрипта.

6. отлично для глобальной области видимости все выглядит просто. а как это работает в локальной области видимости
 в локальной области видимости - тоесть внетри какойто функции, все работает точно также. только вместо глобального обекта используется локальный обект - LexicalEnvironment

7. в момент исполнения функции создается обект - LexicalEnvironment - своиства которого это аргументы функции и переменные функции.
    и в момент заверщения исполнения фенкцииб если мы не имеем каких либо решефернций на этот обектб акцентирую внимание если не имеем каких либо референций на этот обект!
    он будет удален

8. отлично но как работают глобальные и локальные переменные вместе? сначала джаваскрипт екзекютор поизет свойтво в LexicalEnvironment, но ф асли там не будет такого проперти то

9. Согласно спецификации, каждая фенкция при создании имеет скрытое свойство [[Scope]] который является ссылкой на композицию обектов declarative environment и object environment. после поиска свойства в LexicalEnvironment екзекютор поищет свойство [[Scope]]

10. а что в случае если у нас функция вложена в функцию?
    все так же очень просто - сначала ищем во втором LE - потом скоупе второй функцииб потом

11. ok. я сказал что LE, будет удален если на него не будет каких либо референций.
 но если мы создадим на него какую либо референцию, то он останется и будет почти идеальным хранилицем секретных данных.
 Почти идеальным потому что это будет мемори лик.

 сщздать такую референцию очень легко, для этого всего лишт нужно сделать вот что
    1. создаем функцию createCounter которая при вызове определит LexicalEnvironment, и запишет в него значение currentCount = 0
    2. после создания LexicalEnvironment функция createCounter, создает и возвращает новую анонимную функцию, ссылку на которую мы записываем в переменную counter
    3. таким образом в переменной counter у нас хранится референция на фенкцию которая своим скоуп иммет LE функции createCounter.
таким очень простым способом мы создали место которое называется hidden scope.

12. все зависимости LE между и [[Scope]] не работают для функций созданых с помощью конструктора Function. фенкция созданая таким образом, имеют скоуп омпозицию обектов declarative environment и object environment

13. хоть функция и является отдельным типом данных, но она очень похожа на обект(на самом деле все сложные типы данных это bullshit, есть только обект, и все что походе на обект)
    Есть возможность записывать в функцию свойства как в просто обект.
    поэтому фенкцию которая считает свои вызовы можно переписать используя внутренее свойство. гл это не очень хорошо потому что внутренее свойство очень легко переписать.

14. следующий важный момент о фенкциях это this.
    в джаваскрипте кейворд this в больгинстве случаев являяется референцией на обект, в контексте которого вызвана фенкция, у значение этого обекта зависит от того как фенкцию вызвали.

    если фенкцию вызвали как матод обекта - this будет ссылкой на этот обект.
    если фенкцию вызвали непосредственно - то this, будет либо window либо undefined в сктикт моде
    если вызывается конструктор с помощтю ключевого слоав new то
    если фенкцию вызвали в качестве обработчика события - то this бубет референцией на элемент на котором словили это событие
    так же this можно передать в фенкци явно, для этого можно использовать несколько методов таких как call, apply.

15. вот тут пример как можно явно указать в функции this c помощью метода call - первым аргументом фенкции call, является ссылка на обект который бедут использован в качестве this,
 а последующие аргументы - аргементы которые будет переданны в вызываемую функцию. в нашем слечае showFullName не принимает никаких аргументов - поэтому call имеет только 1 агрумент - ссылка на this.

16. разница между тем как работает call и apply только в том как передаются аргементы в исходную функцию которая будет вызвана, тоесть если фенция не принимает никаких аргументов - то разницы нет никакой, нсли функция принимает аргументы - то в call эти аргементы передаются через запятую, а в apply просто массивом

17. отлично если мне нужно вызвать функцию и передать теда явно this можно использовать call/apply но если я не хочу вызывать функцию сейчас в данный момент, а хочу сделать это позже, незнаю когда но позже.
 для этого есть замеяаательный метод bind - метод bind возвразает новую фунцию, с четко зафиксированым this

18. фиксировать можно не только this, но даже аргументы, такой паттерн называется curring, и реализуется конечто же с помощью метода bind

19 Ok мы знаем как вызвать функциюб передав ей определенный this и аргументы с помощтю метода apply или call. а теперь представим такую ситуацию, есть функция логина, она написана в какомто модуле,
 неизветсно неизветсна как она работает потому что там 600 строк, и гит блейм показывает что ее написал мадукар капмидори, там еще какойто дикий this, тронешь ее и она развалиться.
 но к сожелению пришел рекыест добавить внутри проверку логин должен, должен быть произвиден только для юзера админ. если не админ то нужно мягко человеку сказать gtfo
 есть очень хорощий паттерн програмирования который называется декоратор - создание фенкции врапера которая будет использовать уже существующую фенкциональность, и добавляя к ней ноыую функциональность

20 мы создали новую фенкцию updatedLogin которая проверяет является ли юзер админом, и если так - то мы вызываем метод логин, передавая туда его дикий зис, если не является то не вызываем фенкцию login - задекорировали старую фенкия.

