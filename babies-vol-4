1. в лдаваскрипте все переменные можно условно разделить на два типа:
    - локальные - переменные определенные внутри какой-то фунцкции или блока кода - тоесть доступные только внутри функции или блока кода
    - глобальные - переменные которые не находятся внутри функции или блока кода - тоесть доступные везде.

2/3  все шлобальные переменные(созданые с помоштю var или FD) являются свойствами или методами глобального обьекта или подругому это(object environment record), в браузере таким шлобальным обектом является window.
 поэтому когда мы пишем highFive или myBestFunc, это все равно что написать window.highFive = 5;.

4. но оьращаю ваше внимание что так работает только при инициализации переменной с помощтю кейворда var. при использовании let или const
создается блочная переменная которая не является свойством глобального обекта, но является частью declarative environment.

5. давайте еще раз вспомним как работает хоистинг. хоистинг возможет потому что скрипт исполняется в две фазы.
    1. чтение скрипта - инициальзиция переменных.
    2. исполнение скрипта.

6. отлично для глобальной области видимости все выглядит просто. а как это работает в локальной области видимости
 в локальной области видимости - тоесть внетри какойто функции, все работает точно также. только вместо глобального обекта используется локальный обект - LexicalEnvironment

7. в момент исполнения функции создается обект - LexicalEnvironment - своиства которого это аргументы функции и переменные функции.
    и в момент заверщения исполнения фенкцииб если мы не имеем каких либо решефернций на этот обектб акцентирую внимание если не имеем каких либо референций на этот обект!
    он будет удален

8. отлично но как работают глобальные и локальные переменные вместе? сначала джаваскрипт екзекютор поизет свойтво в LexicalEnvironment, но ф асли там не будет такого проперти то

9. Согласно спецификации, каждая фенкция при создании имеет скрытое свойство [[Scope]] который является ссылкой на композицию обектов declarative environment и object environment. после поиска свойства в LexicalEnvironment екзекютор поищет свойство [[Scope]]

10. а что в случае если у нас функция вложена в функцию?
    все так же очень просто - сначала ищем во втором LE - потом скоупе второй функцииб потом

11. ok. я сказал что LE, будет удален если на него не будет каких либо референций.
 но если мы создадим на него какую либо референцию, то он останется и будет почти идеальным хранилицем секретных данных.
 Почти идеальным потому что это будет мемори лик.

 сщздать такую референцию очень легко, для этого всего лишт нужно сделать вот что
    1. создаем функцию createCounter которая при вызове определит LexicalEnvironment, и запишет в него значение currentCount = 0
    2. после создания LexicalEnvironment функция createCounter, создает и возвращает новую анонимную функцию, ссылку на которую мы записываем в переменную counter
    3. таким образом в переменной counter у нас хранится референция на фенкцию которая своим скоуп иммет LE функции createCounter.
таким очень простым способом мы создали место которое называется hidden scope.

12. все зависимости LE между и [[Scope]] не работают для функций созданых с помощью конструктора Function. фенкция созданая таким образом, имеют скоуп омпозицию обектов declarative environment и object environment

13. хоть функция и является отдельным типом данных, но она очень похожа на обект(на самом деле все сложные типы данных это bullshit, есть только обект, и все что походе на обект)
    Есть возможность записывать в функцию свойства как в просто обект.
    поэтому фенкцию которая считает свои вызовы можно переписать используя внутренее свойство. гл это не очень хорошо потому что внутренее свойство очень легко переписать.

14. следующий важный момент о фенкциях это this.
    в джаваскрипте кейворд this в больгинстве случаев являяется референцией на обект, в контексте которого вызвана фенкция, у значение этого обекта зависит от того как фенкцию вызвали.

    если фенкцию вызвали как матод обекта - this будет ссылкой на этот обект.
    если фенкцию вызвали непосредственно - то this, будет либо window либо undefined в сктикт моде
    если вызывается конструктор с помощтю ключевого слоав new то
    если фенкцию вызвали в качестве обработчика события - то this бубет референцией на элемент на котором словили это событие


